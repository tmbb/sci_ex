// -----------------------------------------------------
// Autogenerated file - edits to this file will be lost
// -----------------------------------------------------

use ndarray::{azip, par_azip, Array1, Array2, Array3, Array4, Array5, Array6};
use libm::Libm;
use crate::datatypes::*;

#[rustler::nif]
pub fn math_float64_floor_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_floor_scalar(x: f64) -> f64 {
    f64::floor(x)
}

#[rustler::nif]
pub fn math_float64_floor_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_floor_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_floor_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_floor_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_floor_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::floor(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_scalar(x: f64) -> f64 {
    f64::ceil(x)
}

#[rustler::nif]
pub fn math_float64_ceil_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ceil_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ceil(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_scalar(x: f64) -> f64 {
    f64::round(x)
}

#[rustler::nif]
pub fn math_float64_round_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_scalar(x: f64) -> f64 {
    f64::round_ties_even(x)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_round_ties_even_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::round_ties_even(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_scalar(x: f64) -> f64 {
    f64::trunc(x)
}

#[rustler::nif]
pub fn math_float64_trunc_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_trunc_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::trunc(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_scalar(x: f64) -> f64 {
    f64::fract(x)
}

#[rustler::nif]
pub fn math_float64_fract_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_fract_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::fract(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array1_array1_array1(x: ExFloat64Array1, a: ExFloat64Array1, b: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array1_array1_scalar(x: ExFloat64Array1, a: ExFloat64Array1, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array1_scalar_array1(x: ExFloat64Array1, a: f64, b: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array1_scalar_scalar(x: ExFloat64Array1, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array1_array1(x: f64, a: ExFloat64Array1, b: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array1_scalar(x: f64, a: ExFloat64Array1, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array1(x: f64, a: f64, b: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_scalar(x: f64, a: f64, b: f64) -> f64 {
    f64::mul_add(x, a, b)
}

#[rustler::nif]
pub fn math_float64_mul_add_array2_array2_array2(x: ExFloat64Array2, a: ExFloat64Array2, b: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array2_array2_scalar(x: ExFloat64Array2, a: ExFloat64Array2, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array2_scalar_array2(x: ExFloat64Array2, a: f64, b: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array2_scalar_scalar(x: ExFloat64Array2, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array2_array2(x: f64, a: ExFloat64Array2, b: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array2_scalar(x: f64, a: ExFloat64Array2, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array2(x: f64, a: f64, b: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array3_array3_array3(x: ExFloat64Array3, a: ExFloat64Array3, b: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array3_array3_scalar(x: ExFloat64Array3, a: ExFloat64Array3, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array3_scalar_array3(x: ExFloat64Array3, a: f64, b: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array3_scalar_scalar(x: ExFloat64Array3, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array3_array3(x: f64, a: ExFloat64Array3, b: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array3_scalar(x: f64, a: ExFloat64Array3, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array3(x: f64, a: f64, b: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array4_array4_array4(x: ExFloat64Array4, a: ExFloat64Array4, b: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array4_array4_scalar(x: ExFloat64Array4, a: ExFloat64Array4, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array4_scalar_array4(x: ExFloat64Array4, a: f64, b: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array4_scalar_scalar(x: ExFloat64Array4, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array4_array4(x: f64, a: ExFloat64Array4, b: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array4_scalar(x: f64, a: ExFloat64Array4, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array4(x: f64, a: f64, b: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array5_array5_array5(x: ExFloat64Array5, a: ExFloat64Array5, b: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array5_array5_scalar(x: ExFloat64Array5, a: ExFloat64Array5, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array5_scalar_array5(x: ExFloat64Array5, a: f64, b: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array5_scalar_scalar(x: ExFloat64Array5, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array5_array5(x: f64, a: ExFloat64Array5, b: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array5_scalar(x: f64, a: ExFloat64Array5, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array5(x: f64, a: f64, b: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array6_array6_array6(x: ExFloat64Array6, a: ExFloat64Array6, b: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array6_array6_scalar(x: ExFloat64Array6, a: ExFloat64Array6, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array6_scalar_array6(x: ExFloat64Array6, a: f64, b: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_array6_scalar_scalar(x: ExFloat64Array6, a: f64, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array6_array6(x: f64, a: ExFloat64Array6, b: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0,
                  &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0,
                       &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_array6_scalar(x: f64, a: ExFloat64Array6, b: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(a.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&a.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &a in &a.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &a in &a.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_mul_add_scalar_scalar_array6(x: f64, a: f64, b: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(b.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&b.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &b in &b.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &b in &b.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::mul_add(x, a, b);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array1_array1(x: ExFloat64Array1, rhs: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array1_scalar(x: ExFloat64Array1, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array1(x: f64, rhs: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_scalar(x: f64, rhs: f64) -> f64 {
    f64::div_euclid(x, rhs)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array2_array2(x: ExFloat64Array2, rhs: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array2_scalar(x: ExFloat64Array2, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array2(x: f64, rhs: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array3_array3(x: ExFloat64Array3, rhs: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array3_scalar(x: ExFloat64Array3, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array3(x: f64, rhs: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array4_array4(x: ExFloat64Array4, rhs: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array4_scalar(x: ExFloat64Array4, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array4(x: f64, rhs: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array5_array5(x: ExFloat64Array5, rhs: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array5_scalar(x: ExFloat64Array5, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array5(x: f64, rhs: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array6_array6(x: ExFloat64Array6, rhs: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_array6_scalar(x: ExFloat64Array6, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_div_euclid_scalar_array6(x: f64, rhs: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::div_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array1_array1(x: ExFloat64Array1, rhs: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array1_scalar(x: ExFloat64Array1, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array1(x: f64, rhs: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_scalar(x: f64, rhs: f64) -> f64 {
    f64::rem_euclid(x, rhs)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array2_array2(x: ExFloat64Array2, rhs: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array2_scalar(x: ExFloat64Array2, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array2(x: f64, rhs: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array3_array3(x: ExFloat64Array3, rhs: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array3_scalar(x: ExFloat64Array3, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array3(x: f64, rhs: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array4_array4(x: ExFloat64Array4, rhs: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array4_scalar(x: ExFloat64Array4, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array4(x: f64, rhs: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array5_array5(x: ExFloat64Array5, rhs: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array5_scalar(x: ExFloat64Array5, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array5(x: f64, rhs: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array6_array6(x: ExFloat64Array6, rhs: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_array6_scalar(x: ExFloat64Array6, rhs: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_rem_euclid_scalar_array6(x: f64, rhs: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(rhs.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&rhs.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &rhs in &rhs.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &rhs in &rhs.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::rem_euclid(x, rhs);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_array1_scalar(x: ExFloat64Array1, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_scalar_scalar(x: f64, n: i32) -> f64 {
    f64::powi(x, n)
}

#[rustler::nif]
pub fn math_float64_powi_array2_scalar(x: ExFloat64Array2, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_array3_scalar(x: ExFloat64Array3, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_array4_scalar(x: ExFloat64Array4, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_array5_scalar(x: ExFloat64Array5, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powi_array6_scalar(x: ExFloat64Array6, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powi(x, n);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array1_array1(x: ExFloat64Array1, n: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array1_scalar(x: ExFloat64Array1, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array1(x: f64, n: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_scalar(x: f64, n: f64) -> f64 {
    f64::powf(x, n)
}

#[rustler::nif]
pub fn math_float64_powf_array2_array2(x: ExFloat64Array2, n: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array2_scalar(x: ExFloat64Array2, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array2(x: f64, n: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array3_array3(x: ExFloat64Array3, n: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array3_scalar(x: ExFloat64Array3, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array3(x: f64, n: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array4_array4(x: ExFloat64Array4, n: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array4_scalar(x: ExFloat64Array4, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array4(x: f64, n: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array5_array5(x: ExFloat64Array5, n: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array5_scalar(x: ExFloat64Array5, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array5(x: f64, n: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array6_array6(x: ExFloat64Array6, n: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_array6_scalar(x: ExFloat64Array6, n: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_powf_scalar_array6(x: f64, n: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(n.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&n.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &n in &n.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &n in &n.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::powf(x, n);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_scalar(x: f64) -> f64 {
    f64::sqrt(x)
}

#[rustler::nif]
pub fn math_float64_sqrt_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sqrt_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sqrt(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_scalar(x: f64) -> f64 {
    f64::exp(x)
}

#[rustler::nif]
pub fn math_float64_exp_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_scalar(x: f64) -> f64 {
    f64::exp2(x)
}

#[rustler::nif]
pub fn math_float64_exp2_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp2_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp2(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_scalar(x: f64) -> f64 {
    f64::ln(x)
}

#[rustler::nif]
pub fn math_float64_ln_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array1_array1(x: ExFloat64Array1, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array1_scalar(x: ExFloat64Array1, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array1(x: f64, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_scalar(x: f64, base: f64) -> f64 {
    f64::log(x, base)
}

#[rustler::nif]
pub fn math_float64_log_array2_array2(x: ExFloat64Array2, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array2_scalar(x: ExFloat64Array2, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array2(x: f64, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array3_array3(x: ExFloat64Array3, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array3_scalar(x: ExFloat64Array3, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array3(x: f64, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array4_array4(x: ExFloat64Array4, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array4_scalar(x: ExFloat64Array4, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array4(x: f64, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array5_array5(x: ExFloat64Array5, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array5_scalar(x: ExFloat64Array5, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array5(x: f64, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array6_array6(x: ExFloat64Array6, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_array6_scalar(x: ExFloat64Array6, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log_scalar_array6(x: f64, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log(x, base);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_scalar(x: f64) -> f64 {
    f64::log2(x)
}

#[rustler::nif]
pub fn math_float64_log2_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log2_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log2(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_scalar(x: f64) -> f64 {
    f64::log10(x)
}

#[rustler::nif]
pub fn math_float64_log10_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log10_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::log10(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array1_array1(x: ExFloat64Array1, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array1_scalar(x: ExFloat64Array1, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array1(x: f64, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_scalar(x: f64, other: f64) -> f64 {
    f64::hypot(x, other)
}

#[rustler::nif]
pub fn math_float64_hypot_array2_array2(x: ExFloat64Array2, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array2_scalar(x: ExFloat64Array2, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array2(x: f64, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array3_array3(x: ExFloat64Array3, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array3_scalar(x: ExFloat64Array3, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array3(x: f64, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array4_array4(x: ExFloat64Array4, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array4_scalar(x: ExFloat64Array4, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array4(x: f64, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array5_array5(x: ExFloat64Array5, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array5_scalar(x: ExFloat64Array5, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array5(x: f64, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array6_array6(x: ExFloat64Array6, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_array6_scalar(x: ExFloat64Array6, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_hypot_scalar_array6(x: f64, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::hypot(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_scalar(x: f64) -> f64 {
    f64::sin(x)
}

#[rustler::nif]
pub fn math_float64_sin_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sin_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sin(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_scalar(x: f64) -> f64 {
    f64::cos(x)
}

#[rustler::nif]
pub fn math_float64_cos_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cos_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cos(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_scalar(x: f64) -> f64 {
    f64::tan(x)
}

#[rustler::nif]
pub fn math_float64_tan_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tan_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tan(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_scalar(x: f64) -> f64 {
    f64::asin(x)
}

#[rustler::nif]
pub fn math_float64_asin_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asin_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asin(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_scalar(x: f64) -> f64 {
    f64::acos(x)
}

#[rustler::nif]
pub fn math_float64_acos_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acos_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acos(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_scalar(x: f64) -> f64 {
    f64::atan(x)
}

#[rustler::nif]
pub fn math_float64_atan_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array1_array1(x: ExFloat64Array1, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array1_scalar(x: ExFloat64Array1, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array1(x: f64, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_scalar(x: f64, other: f64) -> f64 {
    f64::atan2(x, other)
}

#[rustler::nif]
pub fn math_float64_atan2_array2_array2(x: ExFloat64Array2, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array2_scalar(x: ExFloat64Array2, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array2(x: f64, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array3_array3(x: ExFloat64Array3, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array3_scalar(x: ExFloat64Array3, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array3(x: f64, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array4_array4(x: ExFloat64Array4, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array4_scalar(x: ExFloat64Array4, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array4(x: f64, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array5_array5(x: ExFloat64Array5, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array5_scalar(x: ExFloat64Array5, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array5(x: f64, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array6_array6(x: ExFloat64Array6, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_array6_scalar(x: ExFloat64Array6, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atan2_scalar_array6(x: f64, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atan2(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_scalar(x: f64) -> f64 {
    f64::exp_m1(x)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_exp_m1_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::exp_m1(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_scalar(x: f64) -> f64 {
    f64::ln_1p(x)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ln_1p_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::ln_1p(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_scalar(x: f64) -> f64 {
    f64::sinh(x)
}

#[rustler::nif]
pub fn math_float64_sinh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_sinh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::sinh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_scalar(x: f64) -> f64 {
    f64::cosh(x)
}

#[rustler::nif]
pub fn math_float64_cosh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cosh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::cosh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_scalar(x: f64) -> f64 {
    f64::tanh(x)
}

#[rustler::nif]
pub fn math_float64_tanh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tanh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::tanh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_scalar(x: f64) -> f64 {
    f64::asinh(x)
}

#[rustler::nif]
pub fn math_float64_asinh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_asinh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::asinh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_scalar(x: f64) -> f64 {
    f64::acosh(x)
}

#[rustler::nif]
pub fn math_float64_acosh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_acosh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::acosh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_scalar(x: f64) -> f64 {
    f64::atanh(x)
}

#[rustler::nif]
pub fn math_float64_atanh_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_atanh_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::atanh(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_scalar(x: f64) -> f64 {
    f64::recip(x)
}

#[rustler::nif]
pub fn math_float64_recip_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_recip_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::recip(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_scalar(x: f64) -> f64 {
    f64::to_degrees(x)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_degrees_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_degrees(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_scalar(x: f64) -> f64 {
    f64::to_radians(x)
}

#[rustler::nif]
pub fn math_float64_to_radians_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_to_radians_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::to_radians(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array1_array1(x: ExFloat64Array1, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array1_scalar(x: ExFloat64Array1, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array1(x: f64, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_scalar(x: f64, other: f64) -> f64 {
    f64::max(x, other)
}

#[rustler::nif]
pub fn math_float64_max_array2_array2(x: ExFloat64Array2, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array2_scalar(x: ExFloat64Array2, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array2(x: f64, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array3_array3(x: ExFloat64Array3, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array3_scalar(x: ExFloat64Array3, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array3(x: f64, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array4_array4(x: ExFloat64Array4, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array4_scalar(x: ExFloat64Array4, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array4(x: f64, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array5_array5(x: ExFloat64Array5, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array5_scalar(x: ExFloat64Array5, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array5(x: f64, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array6_array6(x: ExFloat64Array6, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_array6_scalar(x: ExFloat64Array6, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_max_scalar_array6(x: f64, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::max(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array1_array1(x: ExFloat64Array1, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array1_scalar(x: ExFloat64Array1, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array1(x: f64, other: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_scalar(x: f64, other: f64) -> f64 {
    f64::min(x, other)
}

#[rustler::nif]
pub fn math_float64_min_array2_array2(x: ExFloat64Array2, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array2_scalar(x: ExFloat64Array2, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array2(x: f64, other: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array3_array3(x: ExFloat64Array3, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array3_scalar(x: ExFloat64Array3, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array3(x: f64, other: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array4_array4(x: ExFloat64Array4, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array4_scalar(x: ExFloat64Array4, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array4(x: f64, other: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array5_array5(x: ExFloat64Array5, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array5_scalar(x: ExFloat64Array5, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array5(x: f64, other: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array6_array6(x: ExFloat64Array6, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_array6_scalar(x: ExFloat64Array6, other: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_min_scalar_array6(x: f64, other: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(other.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&other.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &other in &other.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &other in &other.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::min(x, other);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_from_bits_scalar(v: u64) -> f64 {
    f64::from_bits(v)
}

#[rustler::nif]
pub fn math_float64_clamp_array1_array1_array1(x: ExFloat64Array1, min: ExFloat64Array1, max: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array1_array1_scalar(x: ExFloat64Array1, min: ExFloat64Array1, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array1_scalar_array1(x: ExFloat64Array1, min: f64, max: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array1_scalar_scalar(x: ExFloat64Array1, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array1_array1(x: f64, min: ExFloat64Array1, max: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array1_scalar(x: f64, min: ExFloat64Array1, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array1(x: f64, min: f64, max: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_scalar(x: f64, min: f64, max: f64) -> f64 {
    f64::clamp(x, min, max)
}

#[rustler::nif]
pub fn math_float64_clamp_array2_array2_array2(x: ExFloat64Array2, min: ExFloat64Array2, max: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array2_array2_scalar(x: ExFloat64Array2, min: ExFloat64Array2, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array2_scalar_array2(x: ExFloat64Array2, min: f64, max: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array2_scalar_scalar(x: ExFloat64Array2, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array2_array2(x: f64, min: ExFloat64Array2, max: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array2_scalar(x: f64, min: ExFloat64Array2, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array2(x: f64, min: f64, max: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array3_array3_array3(x: ExFloat64Array3, min: ExFloat64Array3, max: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array3_array3_scalar(x: ExFloat64Array3, min: ExFloat64Array3, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array3_scalar_array3(x: ExFloat64Array3, min: f64, max: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array3_scalar_scalar(x: ExFloat64Array3, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array3_array3(x: f64, min: ExFloat64Array3, max: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array3_scalar(x: f64, min: ExFloat64Array3, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array3(x: f64, min: f64, max: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array4_array4_array4(x: ExFloat64Array4, min: ExFloat64Array4, max: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array4_array4_scalar(x: ExFloat64Array4, min: ExFloat64Array4, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array4_scalar_array4(x: ExFloat64Array4, min: f64, max: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array4_scalar_scalar(x: ExFloat64Array4, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array4_array4(x: f64, min: ExFloat64Array4, max: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array4_scalar(x: f64, min: ExFloat64Array4, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array4(x: f64, min: f64, max: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array5_array5_array5(x: ExFloat64Array5, min: ExFloat64Array5, max: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array5_array5_scalar(x: ExFloat64Array5, min: ExFloat64Array5, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array5_scalar_array5(x: ExFloat64Array5, min: f64, max: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array5_scalar_scalar(x: ExFloat64Array5, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array5_array5(x: f64, min: ExFloat64Array5, max: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array5_scalar(x: f64, min: ExFloat64Array5, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array5(x: f64, min: f64, max: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array6_array6_array6(x: ExFloat64Array6, min: ExFloat64Array6, max: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array6_array6_scalar(x: ExFloat64Array6, min: ExFloat64Array6, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array6_scalar_array6(x: ExFloat64Array6, min: f64, max: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_array6_scalar_scalar(x: ExFloat64Array6, min: f64, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array6_array6(x: f64, min: ExFloat64Array6, max: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0,
                  &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0,
                       &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_array6_scalar(x: f64, min: ExFloat64Array6, max: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(min.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&min.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &min in &min.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &min in &min.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_clamp_scalar_scalar_array6(x: f64, min: f64, max: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(max.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&max.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &max in &max.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &max in &max.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::clamp(x, min, max);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_scalar(x: f64) -> f64 {
    f64::abs(x)
}

#[rustler::nif]
pub fn math_float64_abs_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_abs_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::abs(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_scalar(x: f64) -> f64 {
    f64::signum(x)
}

#[rustler::nif]
pub fn math_float64_signum_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_signum_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::signum(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array1_array1(x: ExFloat64Array1, sign: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array1_scalar(x: ExFloat64Array1, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array1(x: f64, sign: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_scalar(x: f64, sign: f64) -> f64 {
    f64::copysign(x, sign)
}

#[rustler::nif]
pub fn math_float64_copysign_array2_array2(x: ExFloat64Array2, sign: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array2_scalar(x: ExFloat64Array2, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array2(x: f64, sign: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array3_array3(x: ExFloat64Array3, sign: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array3_scalar(x: ExFloat64Array3, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array3(x: f64, sign: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array4_array4(x: ExFloat64Array4, sign: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array4_scalar(x: ExFloat64Array4, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array4(x: f64, sign: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array5_array5(x: ExFloat64Array5, sign: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array5_scalar(x: ExFloat64Array5, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array5(x: f64, sign: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array6_array6(x: ExFloat64Array6, sign: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0,
                  &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0,
                       &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_array6_scalar(x: ExFloat64Array6, sign: f64, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_copysign_scalar_array6(x: f64, sign: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(sign.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&sign.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &sign in &sign.resource.0) {
                // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &sign in &sign.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = f64::copysign(x, sign);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_scalar(x: f64) -> f64 {
    Libm::<f64>::cbrt(x)
}

#[rustler::nif]
pub fn math_float64_cbrt_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_cbrt_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::cbrt(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_scalar(x: f64) -> f64 {
    Libm::<f64>::erf(x)
}

#[rustler::nif]
pub fn math_float64_erf_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erf_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erf(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_scalar(x: f64) -> f64 {
    Libm::<f64>::erfc(x)
}

#[rustler::nif]
pub fn math_float64_erfc_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_erfc_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::erfc(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_scalar(x: f64) -> f64 {
    Libm::<f64>::j0(x)
}

#[rustler::nif]
pub fn math_float64_j0_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j0_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j0(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_scalar(x: f64) -> f64 {
    Libm::<f64>::j1(x)
}

#[rustler::nif]
pub fn math_float64_j1_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_j1_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::j1(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_array1_scalar(x: ExFloat64Array1, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_scalar_scalar(x: f64, n: i32) -> f64 {
    Libm::<f64>::ldexp(x, n)
}

#[rustler::nif]
pub fn math_float64_ldexp_array2_scalar(x: ExFloat64Array2, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_array3_scalar(x: ExFloat64Array3, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_array4_scalar(x: ExFloat64Array4, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_array5_scalar(x: ExFloat64Array5, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_ldexp_array6_scalar(x: ExFloat64Array6, n: i32, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::ldexp(x, n);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_scalar(x: f64) -> f64 {
    Libm::<f64>::lgamma(x)
}

#[rustler::nif]
pub fn math_float64_lgamma_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_lgamma_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::lgamma(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_scalar(x: f64) -> f64 {
    Libm::<f64>::log1p(x)
}

#[rustler::nif]
pub fn math_float64_log1p_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_log1p_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::log1p(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_scalar(x: f64) -> f64 {
    Libm::<f64>::tgamma(x)
}

#[rustler::nif]
pub fn math_float64_tgamma_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_tgamma_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::tgamma(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_scalar(x: f64) -> f64 {
    Libm::<f64>::y0(x)
}

#[rustler::nif]
pub fn math_float64_y0_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y0_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y0(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_array1(x: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array1 {  
    let mut output_array = Array1::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_scalar(x: f64) -> f64 {
    Libm::<f64>::y1(x)
}

#[rustler::nif]
pub fn math_float64_y1_array2(x: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array2 {  
    let mut output_array = Array2::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_array3(x: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array3 {  
    let mut output_array = Array3::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_array4(x: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array4 {  
    let mut output_array = Array4::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_array5(x: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array5 {  
    let mut output_array = Array5::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float64_y1_array6(x: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExFloat64Array6 {  
    let mut output_array = Array6::zeros(x.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&x.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &x in &x.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &x in &x.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Libm::<f64>::y1(x);
            });
        }
    };

    ExFloat64Array6::new(output_array)
}
