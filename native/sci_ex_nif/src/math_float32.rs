// -----------------------------------------------------
// Autogenerated file - edits to this file will be lost
// -----------------------------------------------------

use ndarray::{azip, Array1, Array2, Array3, Array4, Array5, Array6};
use crate::datatypes::*;

#[rustler::nif]
pub fn math_float32_floor_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_floor_scalar(x: f32) -> f32 {
    f32::floor(x)
}

#[rustler::nif]
pub fn math_float32_floor_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_floor_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_floor_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_floor_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_floor_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::floor(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_scalar(x: f32) -> f32 {
    f32::ceil(x)
}

#[rustler::nif]
pub fn math_float32_ceil_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ceil_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ceil(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_scalar(x: f32) -> f32 {
    f32::round(x)
}

#[rustler::nif]
pub fn math_float32_round_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_scalar(x: f32) -> f32 {
    f32::round_ties_even(x)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_round_ties_even_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::round_ties_even(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_scalar(x: f32) -> f32 {
    f32::trunc(x)
}

#[rustler::nif]
pub fn math_float32_trunc_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_trunc_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::trunc(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_scalar(x: f32) -> f32 {
    f32::fract(x)
}

#[rustler::nif]
pub fn math_float32_fract_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_fract_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::fract(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array1_array1_array1(x: ExFloat32Array1, a: ExFloat32Array1, b: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array1_array1_scalar(x: ExFloat32Array1, a: ExFloat32Array1, b: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array1_scalar_array1(x: ExFloat32Array1, a: f32, b: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array1_scalar_scalar(x: ExFloat32Array1, a: f32, b: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array1_array1(x: f32, a: ExFloat32Array1, b: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array1_scalar(x: f32, a: ExFloat32Array1, b: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array1(x: f32, a: f32, b: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_scalar(x: f32, a: f32, b: f32) -> f32 {
    f32::mul_add(x, a, b)
}

#[rustler::nif]
pub fn math_float32_mul_add_array2_array2_array2(x: ExFloat32Array2, a: ExFloat32Array2, b: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array2_array2_scalar(x: ExFloat32Array2, a: ExFloat32Array2, b: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array2_scalar_array2(x: ExFloat32Array2, a: f32, b: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array2_scalar_scalar(x: ExFloat32Array2, a: f32, b: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array2_array2(x: f32, a: ExFloat32Array2, b: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array2_scalar(x: f32, a: ExFloat32Array2, b: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array2(x: f32, a: f32, b: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array3_array3_array3(x: ExFloat32Array3, a: ExFloat32Array3, b: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array3_array3_scalar(x: ExFloat32Array3, a: ExFloat32Array3, b: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array3_scalar_array3(x: ExFloat32Array3, a: f32, b: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array3_scalar_scalar(x: ExFloat32Array3, a: f32, b: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array3_array3(x: f32, a: ExFloat32Array3, b: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array3_scalar(x: f32, a: ExFloat32Array3, b: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array3(x: f32, a: f32, b: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array4_array4_array4(x: ExFloat32Array4, a: ExFloat32Array4, b: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array4_array4_scalar(x: ExFloat32Array4, a: ExFloat32Array4, b: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array4_scalar_array4(x: ExFloat32Array4, a: f32, b: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array4_scalar_scalar(x: ExFloat32Array4, a: f32, b: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array4_array4(x: f32, a: ExFloat32Array4, b: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array4_scalar(x: f32, a: ExFloat32Array4, b: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array4(x: f32, a: f32, b: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array5_array5_array5(x: ExFloat32Array5, a: ExFloat32Array5, b: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array5_array5_scalar(x: ExFloat32Array5, a: ExFloat32Array5, b: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array5_scalar_array5(x: ExFloat32Array5, a: f32, b: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array5_scalar_scalar(x: ExFloat32Array5, a: f32, b: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array5_array5(x: f32, a: ExFloat32Array5, b: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array5_scalar(x: f32, a: ExFloat32Array5, b: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array5(x: f32, a: f32, b: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array6_array6_array6(x: ExFloat32Array6, a: ExFloat32Array6, b: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array6_array6_scalar(x: ExFloat32Array6, a: ExFloat32Array6, b: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array6_scalar_array6(x: ExFloat32Array6, a: f32, b: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_array6_scalar_scalar(x: ExFloat32Array6, a: f32, b: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array6_array6(x: f32, a: ExFloat32Array6, b: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_array6_scalar(x: f32, a: ExFloat32Array6, b: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(a.resource.0.dim());
    azip!((output_array in &mut output_array,
           &a in &a.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_mul_add_scalar_scalar_array6(x: f32, a: f32, b: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(b.resource.0.dim());
    azip!((output_array in &mut output_array,
           &b in &b.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::mul_add(x, a, b);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array1_array1(x: ExFloat32Array1, rhs: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array1_scalar(x: ExFloat32Array1, rhs: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array1(x: f32, rhs: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_scalar(x: f32, rhs: f32) -> f32 {
    f32::div_euclid(x, rhs)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array2_array2(x: ExFloat32Array2, rhs: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array2_scalar(x: ExFloat32Array2, rhs: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array2(x: f32, rhs: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array3_array3(x: ExFloat32Array3, rhs: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array3_scalar(x: ExFloat32Array3, rhs: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array3(x: f32, rhs: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array4_array4(x: ExFloat32Array4, rhs: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array4_scalar(x: ExFloat32Array4, rhs: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array4(x: f32, rhs: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array5_array5(x: ExFloat32Array5, rhs: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array5_scalar(x: ExFloat32Array5, rhs: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array5(x: f32, rhs: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array6_array6(x: ExFloat32Array6, rhs: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_array6_scalar(x: ExFloat32Array6, rhs: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_div_euclid_scalar_array6(x: f32, rhs: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::div_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array1_array1(x: ExFloat32Array1, rhs: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array1_scalar(x: ExFloat32Array1, rhs: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array1(x: f32, rhs: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_scalar(x: f32, rhs: f32) -> f32 {
    f32::rem_euclid(x, rhs)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array2_array2(x: ExFloat32Array2, rhs: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array2_scalar(x: ExFloat32Array2, rhs: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array2(x: f32, rhs: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array3_array3(x: ExFloat32Array3, rhs: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array3_scalar(x: ExFloat32Array3, rhs: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array3(x: f32, rhs: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array4_array4(x: ExFloat32Array4, rhs: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array4_scalar(x: ExFloat32Array4, rhs: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array4(x: f32, rhs: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array5_array5(x: ExFloat32Array5, rhs: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array5_scalar(x: ExFloat32Array5, rhs: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array5(x: f32, rhs: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array6_array6(x: ExFloat32Array6, rhs: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_array6_scalar(x: ExFloat32Array6, rhs: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_rem_euclid_scalar_array6(x: f32, rhs: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(rhs.resource.0.dim());
    azip!((output_array in &mut output_array,
           &rhs in &rhs.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::rem_euclid(x, rhs);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_array1_scalar(x: ExFloat32Array1, n: i32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_scalar_scalar(x: f32, n: i32) -> f32 {
    f32::powi(x, n)
}

#[rustler::nif]
pub fn math_float32_powi_array2_scalar(x: ExFloat32Array2, n: i32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_array3_scalar(x: ExFloat32Array3, n: i32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_array4_scalar(x: ExFloat32Array4, n: i32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_array5_scalar(x: ExFloat32Array5, n: i32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powi_array6_scalar(x: ExFloat32Array6, n: i32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powi(x, n);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array1_array1(x: ExFloat32Array1, n: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array1_scalar(x: ExFloat32Array1, n: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array1(x: f32, n: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_scalar(x: f32, n: f32) -> f32 {
    f32::powf(x, n)
}

#[rustler::nif]
pub fn math_float32_powf_array2_array2(x: ExFloat32Array2, n: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array2_scalar(x: ExFloat32Array2, n: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array2(x: f32, n: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array3_array3(x: ExFloat32Array3, n: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array3_scalar(x: ExFloat32Array3, n: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array3(x: f32, n: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array4_array4(x: ExFloat32Array4, n: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array4_scalar(x: ExFloat32Array4, n: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array4(x: f32, n: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array5_array5(x: ExFloat32Array5, n: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array5_scalar(x: ExFloat32Array5, n: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array5(x: f32, n: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array6_array6(x: ExFloat32Array6, n: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_array6_scalar(x: ExFloat32Array6, n: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_powf_scalar_array6(x: f32, n: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(n.resource.0.dim());
    azip!((output_array in &mut output_array,
           &n in &n.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::powf(x, n);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_scalar(x: f32) -> f32 {
    f32::sqrt(x)
}

#[rustler::nif]
pub fn math_float32_sqrt_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sqrt_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sqrt(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_scalar(x: f32) -> f32 {
    f32::exp(x)
}

#[rustler::nif]
pub fn math_float32_exp_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_scalar(x: f32) -> f32 {
    f32::exp2(x)
}

#[rustler::nif]
pub fn math_float32_exp2_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp2_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp2(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_scalar(x: f32) -> f32 {
    f32::ln(x)
}

#[rustler::nif]
pub fn math_float32_ln_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array1_array1(x: ExFloat32Array1, base: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array1_scalar(x: ExFloat32Array1, base: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array1(x: f32, base: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_scalar(x: f32, base: f32) -> f32 {
    f32::log(x, base)
}

#[rustler::nif]
pub fn math_float32_log_array2_array2(x: ExFloat32Array2, base: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array2_scalar(x: ExFloat32Array2, base: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array2(x: f32, base: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array3_array3(x: ExFloat32Array3, base: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array3_scalar(x: ExFloat32Array3, base: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array3(x: f32, base: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array4_array4(x: ExFloat32Array4, base: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array4_scalar(x: ExFloat32Array4, base: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array4(x: f32, base: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array5_array5(x: ExFloat32Array5, base: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array5_scalar(x: ExFloat32Array5, base: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array5(x: f32, base: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array6_array6(x: ExFloat32Array6, base: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_array6_scalar(x: ExFloat32Array6, base: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log_scalar_array6(x: f32, base: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(base.resource.0.dim());
    azip!((output_array in &mut output_array,
           &base in &base.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log(x, base);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_scalar(x: f32) -> f32 {
    f32::log2(x)
}

#[rustler::nif]
pub fn math_float32_log2_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log2_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log2(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_scalar(x: f32) -> f32 {
    f32::log10(x)
}

#[rustler::nif]
pub fn math_float32_log10_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log10_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::log10(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array1_array1(x: ExFloat32Array1, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array1_scalar(x: ExFloat32Array1, other: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array1(x: f32, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_scalar(x: f32, other: f32) -> f32 {
    f32::hypot(x, other)
}

#[rustler::nif]
pub fn math_float32_hypot_array2_array2(x: ExFloat32Array2, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array2_scalar(x: ExFloat32Array2, other: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array2(x: f32, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array3_array3(x: ExFloat32Array3, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array3_scalar(x: ExFloat32Array3, other: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array3(x: f32, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array4_array4(x: ExFloat32Array4, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array4_scalar(x: ExFloat32Array4, other: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array4(x: f32, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array5_array5(x: ExFloat32Array5, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array5_scalar(x: ExFloat32Array5, other: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array5(x: f32, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array6_array6(x: ExFloat32Array6, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_array6_scalar(x: ExFloat32Array6, other: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_hypot_scalar_array6(x: f32, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::hypot(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_scalar(x: f32) -> f32 {
    f32::sin(x)
}

#[rustler::nif]
pub fn math_float32_sin_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sin_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sin(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_scalar(x: f32) -> f32 {
    f32::cos(x)
}

#[rustler::nif]
pub fn math_float32_cos_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cos_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cos(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_scalar(x: f32) -> f32 {
    f32::tan(x)
}

#[rustler::nif]
pub fn math_float32_tan_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tan_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tan(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_scalar(x: f32) -> f32 {
    f32::asin(x)
}

#[rustler::nif]
pub fn math_float32_asin_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asin_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asin(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_scalar(x: f32) -> f32 {
    f32::acos(x)
}

#[rustler::nif]
pub fn math_float32_acos_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acos_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acos(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_scalar(x: f32) -> f32 {
    f32::atan(x)
}

#[rustler::nif]
pub fn math_float32_atan_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array1_array1(x: ExFloat32Array1, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array1_scalar(x: ExFloat32Array1, other: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array1(x: f32, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_scalar(x: f32, other: f32) -> f32 {
    f32::atan2(x, other)
}

#[rustler::nif]
pub fn math_float32_atan2_array2_array2(x: ExFloat32Array2, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array2_scalar(x: ExFloat32Array2, other: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array2(x: f32, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array3_array3(x: ExFloat32Array3, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array3_scalar(x: ExFloat32Array3, other: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array3(x: f32, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array4_array4(x: ExFloat32Array4, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array4_scalar(x: ExFloat32Array4, other: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array4(x: f32, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array5_array5(x: ExFloat32Array5, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array5_scalar(x: ExFloat32Array5, other: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array5(x: f32, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array6_array6(x: ExFloat32Array6, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_array6_scalar(x: ExFloat32Array6, other: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atan2_scalar_array6(x: f32, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atan2(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_scalar(x: f32) -> f32 {
    f32::exp_m1(x)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_exp_m1_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::exp_m1(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_scalar(x: f32) -> f32 {
    f32::ln_1p(x)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ln_1p_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::ln_1p(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_scalar(x: f32) -> f32 {
    f32::sinh(x)
}

#[rustler::nif]
pub fn math_float32_sinh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_sinh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::sinh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_scalar(x: f32) -> f32 {
    f32::cosh(x)
}

#[rustler::nif]
pub fn math_float32_cosh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cosh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::cosh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_scalar(x: f32) -> f32 {
    f32::tanh(x)
}

#[rustler::nif]
pub fn math_float32_tanh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tanh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::tanh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_scalar(x: f32) -> f32 {
    f32::asinh(x)
}

#[rustler::nif]
pub fn math_float32_asinh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_asinh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::asinh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_scalar(x: f32) -> f32 {
    f32::acosh(x)
}

#[rustler::nif]
pub fn math_float32_acosh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_acosh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::acosh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_scalar(x: f32) -> f32 {
    f32::atanh(x)
}

#[rustler::nif]
pub fn math_float32_atanh_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_atanh_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::atanh(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_scalar(x: f32) -> f32 {
    f32::recip(x)
}

#[rustler::nif]
pub fn math_float32_recip_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_recip_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::recip(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_scalar(x: f32) -> f32 {
    f32::to_degrees(x)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_degrees_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_degrees(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_scalar(x: f32) -> f32 {
    f32::to_radians(x)
}

#[rustler::nif]
pub fn math_float32_to_radians_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_to_radians_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::to_radians(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array1_array1(x: ExFloat32Array1, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array1_scalar(x: ExFloat32Array1, other: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array1(x: f32, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_scalar(x: f32, other: f32) -> f32 {
    f32::max(x, other)
}

#[rustler::nif]
pub fn math_float32_max_array2_array2(x: ExFloat32Array2, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array2_scalar(x: ExFloat32Array2, other: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array2(x: f32, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array3_array3(x: ExFloat32Array3, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array3_scalar(x: ExFloat32Array3, other: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array3(x: f32, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array4_array4(x: ExFloat32Array4, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array4_scalar(x: ExFloat32Array4, other: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array4(x: f32, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array5_array5(x: ExFloat32Array5, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array5_scalar(x: ExFloat32Array5, other: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array5(x: f32, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array6_array6(x: ExFloat32Array6, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_array6_scalar(x: ExFloat32Array6, other: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_max_scalar_array6(x: f32, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::max(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array1_array1(x: ExFloat32Array1, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array1_scalar(x: ExFloat32Array1, other: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array1(x: f32, other: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_scalar(x: f32, other: f32) -> f32 {
    f32::min(x, other)
}

#[rustler::nif]
pub fn math_float32_min_array2_array2(x: ExFloat32Array2, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array2_scalar(x: ExFloat32Array2, other: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array2(x: f32, other: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array3_array3(x: ExFloat32Array3, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array3_scalar(x: ExFloat32Array3, other: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array3(x: f32, other: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array4_array4(x: ExFloat32Array4, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array4_scalar(x: ExFloat32Array4, other: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array4(x: f32, other: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array5_array5(x: ExFloat32Array5, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array5_scalar(x: ExFloat32Array5, other: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array5(x: f32, other: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array6_array6(x: ExFloat32Array6, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_array6_scalar(x: ExFloat32Array6, other: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_min_scalar_array6(x: f32, other: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(other.resource.0.dim());
    azip!((output_array in &mut output_array,
           &other in &other.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::min(x, other);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_from_bits_scalar(v: u32) -> f32 {
    f32::from_bits(v)
}

#[rustler::nif]
pub fn math_float32_clamp_array1_array1_array1(x: ExFloat32Array1, min: ExFloat32Array1, max: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array1_array1_scalar(x: ExFloat32Array1, min: ExFloat32Array1, max: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array1_scalar_array1(x: ExFloat32Array1, min: f32, max: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array1_scalar_scalar(x: ExFloat32Array1, min: f32, max: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array1_array1(x: f32, min: ExFloat32Array1, max: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array1_scalar(x: f32, min: ExFloat32Array1, max: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array1(x: f32, min: f32, max: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_scalar(x: f32, min: f32, max: f32) -> f32 {
    f32::clamp(x, min, max)
}

#[rustler::nif]
pub fn math_float32_clamp_array2_array2_array2(x: ExFloat32Array2, min: ExFloat32Array2, max: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array2_array2_scalar(x: ExFloat32Array2, min: ExFloat32Array2, max: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array2_scalar_array2(x: ExFloat32Array2, min: f32, max: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array2_scalar_scalar(x: ExFloat32Array2, min: f32, max: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array2_array2(x: f32, min: ExFloat32Array2, max: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array2_scalar(x: f32, min: ExFloat32Array2, max: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array2(x: f32, min: f32, max: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array3_array3_array3(x: ExFloat32Array3, min: ExFloat32Array3, max: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array3_array3_scalar(x: ExFloat32Array3, min: ExFloat32Array3, max: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array3_scalar_array3(x: ExFloat32Array3, min: f32, max: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array3_scalar_scalar(x: ExFloat32Array3, min: f32, max: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array3_array3(x: f32, min: ExFloat32Array3, max: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array3_scalar(x: f32, min: ExFloat32Array3, max: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array3(x: f32, min: f32, max: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array4_array4_array4(x: ExFloat32Array4, min: ExFloat32Array4, max: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array4_array4_scalar(x: ExFloat32Array4, min: ExFloat32Array4, max: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array4_scalar_array4(x: ExFloat32Array4, min: f32, max: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array4_scalar_scalar(x: ExFloat32Array4, min: f32, max: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array4_array4(x: f32, min: ExFloat32Array4, max: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array4_scalar(x: f32, min: ExFloat32Array4, max: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array4(x: f32, min: f32, max: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array5_array5_array5(x: ExFloat32Array5, min: ExFloat32Array5, max: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array5_array5_scalar(x: ExFloat32Array5, min: ExFloat32Array5, max: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array5_scalar_array5(x: ExFloat32Array5, min: f32, max: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array5_scalar_scalar(x: ExFloat32Array5, min: f32, max: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array5_array5(x: f32, min: ExFloat32Array5, max: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array5_scalar(x: f32, min: ExFloat32Array5, max: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array5(x: f32, min: f32, max: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array6_array6_array6(x: ExFloat32Array6, min: ExFloat32Array6, max: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array6_array6_scalar(x: ExFloat32Array6, min: ExFloat32Array6, max: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array6_scalar_array6(x: ExFloat32Array6, min: f32, max: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_array6_scalar_scalar(x: ExFloat32Array6, min: f32, max: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array6_array6(x: f32, min: ExFloat32Array6, max: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_array6_scalar(x: f32, min: ExFloat32Array6, max: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(min.resource.0.dim());
    azip!((output_array in &mut output_array,
           &min in &min.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_clamp_scalar_scalar_array6(x: f32, min: f32, max: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(max.resource.0.dim());
    azip!((output_array in &mut output_array,
           &max in &max.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::clamp(x, min, max);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_scalar(x: f32) -> f32 {
    f32::abs(x)
}

#[rustler::nif]
pub fn math_float32_abs_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_abs_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::abs(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_array1(x: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_scalar(x: f32) -> f32 {
    f32::signum(x)
}

#[rustler::nif]
pub fn math_float32_signum_array2(x: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_array3(x: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_array4(x: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_array5(x: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_signum_array6(x: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::signum(x);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array1_array1(x: ExFloat32Array1, sign: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array1_scalar(x: ExFloat32Array1, sign: f32) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array1(x: f32, sign: ExFloat32Array1) -> ExFloat32Array1 {
    let mut output_array = Array1::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_scalar(x: f32, sign: f32) -> f32 {
    f32::copysign(x, sign)
}

#[rustler::nif]
pub fn math_float32_copysign_array2_array2(x: ExFloat32Array2, sign: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array2_scalar(x: ExFloat32Array2, sign: f32) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array2(x: f32, sign: ExFloat32Array2) -> ExFloat32Array2 {
    let mut output_array = Array2::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array3_array3(x: ExFloat32Array3, sign: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array3_scalar(x: ExFloat32Array3, sign: f32) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array3(x: f32, sign: ExFloat32Array3) -> ExFloat32Array3 {
    let mut output_array = Array3::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array4_array4(x: ExFloat32Array4, sign: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array4_scalar(x: ExFloat32Array4, sign: f32) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array4(x: f32, sign: ExFloat32Array4) -> ExFloat32Array4 {
    let mut output_array = Array4::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array5_array5(x: ExFloat32Array5, sign: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array5_scalar(x: ExFloat32Array5, sign: f32) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array5(x: f32, sign: ExFloat32Array5) -> ExFloat32Array5 {
    let mut output_array = Array5::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array6_array6(x: ExFloat32Array6, sign: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_array6_scalar(x: ExFloat32Array6, sign: f32) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_copysign_scalar_array6(x: f32, sign: ExFloat32Array6) -> ExFloat32Array6 {
    let mut output_array = Array6::zeros(sign.resource.0.dim());
    azip!((output_array in &mut output_array,
           &sign in &sign.resource.0) {
        // Save the result of the operation in the output array
        *output_array = f32::copysign(x, sign);
    });

    ExFloat32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_scalar(x: f64) -> f64 {
    libm::cbrt(x)
}

#[rustler::nif]
pub fn math_float32_cbrt_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_cbrt_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::cbrt(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_scalar(x: f64) -> f64 {
    libm::erf(x)
}

#[rustler::nif]
pub fn math_float32_erf_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erf_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erf(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_scalar(x: f64) -> f64 {
    libm::erfc(x)
}

#[rustler::nif]
pub fn math_float32_erfc_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_erfc_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::erfc(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_scalar(x: f64) -> f64 {
    libm::j0(x)
}

#[rustler::nif]
pub fn math_float32_j0_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j0_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j0(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_scalar(x: f64) -> f64 {
    libm::j1(x)
}

#[rustler::nif]
pub fn math_float32_j1_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_j1_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::j1(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_array1_scalar(x: ExFloat64Array1, n: i32) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_scalar_scalar(x: f64, n: i32) -> f64 {
    libm::ldexp(x, n)
}

#[rustler::nif]
pub fn math_float32_ldexp_array2_scalar(x: ExFloat64Array2, n: i32) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_array3_scalar(x: ExFloat64Array3, n: i32) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_array4_scalar(x: ExFloat64Array4, n: i32) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_array5_scalar(x: ExFloat64Array5, n: i32) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_ldexp_array6_scalar(x: ExFloat64Array6, n: i32) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::ldexp(x, n);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_scalar(x: f64) -> f64 {
    libm::lgamma(x)
}

#[rustler::nif]
pub fn math_float32_lgamma_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_lgamma_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::lgamma(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_scalar(x: f64) -> f64 {
    libm::log1p(x)
}

#[rustler::nif]
pub fn math_float32_log1p_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_log1p_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::log1p(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_scalar(x: f64) -> f64 {
    libm::tgamma(x)
}

#[rustler::nif]
pub fn math_float32_tgamma_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_tgamma_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::tgamma(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_scalar(x: f64) -> f64 {
    libm::y0(x)
}

#[rustler::nif]
pub fn math_float32_y0_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y0_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y0(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_array1(x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_scalar(x: f64) -> f64 {
    libm::y1(x)
}

#[rustler::nif]
pub fn math_float32_y1_array2(x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_array3(x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_array4(x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_array5(x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_y1_array6(x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::y1(x);
    });

    ExFloat64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array1(n: i32, x: ExFloat64Array1) -> ExFloat64Array1 {
    let mut output_array = Array1::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_scalar(n: i32, x: f64) -> f64 {
    libm::yn(n, x)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array2(n: i32, x: ExFloat64Array2) -> ExFloat64Array2 {
    let mut output_array = Array2::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array3(n: i32, x: ExFloat64Array3) -> ExFloat64Array3 {
    let mut output_array = Array3::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array4(n: i32, x: ExFloat64Array4) -> ExFloat64Array4 {
    let mut output_array = Array4::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array5(n: i32, x: ExFloat64Array5) -> ExFloat64Array5 {
    let mut output_array = Array5::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_float32_yn_scalar_array6(n: i32, x: ExFloat64Array6) -> ExFloat64Array6 {
    let mut output_array = Array6::zeros(x.resource.0.dim());
    azip!((output_array in &mut output_array,
           &x in &x.resource.0) {
        // Save the result of the operation in the output array
        *output_array = libm::yn(n, x);
    });

    ExFloat64Array6::new(output_array)
}
