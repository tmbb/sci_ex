// -----------------------------------------------------
// Autogenerated file - edits to this file will be lost
// -----------------------------------------------------

use ndarray::{azip, par_azip, Array1, Array2, Array3, Array4, Array5, Array6};
use ndrustfft::Complex;
use crate::datatypes::*;

#[rustler::nif]
pub fn math_complex64_from_polar_array1_array1(r: ExFloat64Array1, theta: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array1_scalar(r: ExFloat64Array1, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array1(r: f64, theta: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_scalar(r: f64, theta: f64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::from_polar(r, theta))
}

#[rustler::nif]
pub fn math_complex64_from_polar_array2_array2(r: ExFloat64Array2, theta: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array2_scalar(r: ExFloat64Array2, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array2(r: f64, theta: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array3_array3(r: ExFloat64Array3, theta: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array3_scalar(r: ExFloat64Array3, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array3(r: f64, theta: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array4_array4(r: ExFloat64Array4, theta: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array4_scalar(r: ExFloat64Array4, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array4(r: f64, theta: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array5_array5(r: ExFloat64Array5, theta: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array5_scalar(r: ExFloat64Array5, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array5(r: f64, theta: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array6_array6(r: ExFloat64Array6, theta: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_array6_scalar(r: ExFloat64Array6, theta: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_from_polar_scalar_array6(r: f64, theta: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::from_polar(r, theta);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::exp(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_exp_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_exp_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::exp(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::ln(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_ln_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_ln_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::ln(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::sqrt(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_sqrt_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sqrt_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sqrt(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::cbrt(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_cbrt_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cbrt_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cbrt(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array1_array1(z: ExComplex64Array1, exp: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array1_scalar(z: ExComplex64Array1, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array1(z: ExComplex64, exp: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_scalar(z: ExComplex64, exp: f64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::powf(z.resource.0, exp))
}

#[rustler::nif]
pub fn math_complex64_powf_array2_array2(z: ExComplex64Array2, exp: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array2_scalar(z: ExComplex64Array2, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array2(z: ExComplex64, exp: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array3_array3(z: ExComplex64Array3, exp: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array3_scalar(z: ExComplex64Array3, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array3(z: ExComplex64, exp: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array4_array4(z: ExComplex64Array4, exp: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array4_scalar(z: ExComplex64Array4, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array4(z: ExComplex64, exp: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array5_array5(z: ExComplex64Array5, exp: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array5_scalar(z: ExComplex64Array5, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array5(z: ExComplex64, exp: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array6_array6(z: ExComplex64Array6, exp: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_array6_scalar(z: ExComplex64Array6, exp: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z, exp);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powf_scalar_array6(z: ExComplex64, exp: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array1_array1(z: ExComplex64Array1, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array1_scalar(z: ExComplex64Array1, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array1(z: ExComplex64, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_scalar(z: ExComplex64, base: f64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::log(z.resource.0, base))
}

#[rustler::nif]
pub fn math_complex64_log_array2_array2(z: ExComplex64Array2, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array2_scalar(z: ExComplex64Array2, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array2(z: ExComplex64, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array3_array3(z: ExComplex64Array3, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array3_scalar(z: ExComplex64Array3, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array3(z: ExComplex64, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array4_array4(z: ExComplex64Array4, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array4_scalar(z: ExComplex64Array4, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array4(z: ExComplex64, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array5_array5(z: ExComplex64Array5, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array5_scalar(z: ExComplex64Array5, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array5(z: ExComplex64, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array6_array6(z: ExComplex64Array6, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_array6_scalar(z: ExComplex64Array6, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_log_scalar_array6(z: ExComplex64, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::log(z.resource.0, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array1_array1(z: ExComplex64Array1, exp: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array1_scalar(z: ExComplex64Array1, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array1(z: ExComplex64, exp: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_scalar(z: ExComplex64, exp: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::powc(z.resource.0, exp.resource.0))
}

#[rustler::nif]
pub fn math_complex64_powc_array2_array2(z: ExComplex64Array2, exp: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array2_scalar(z: ExComplex64Array2, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array2(z: ExComplex64, exp: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array3_array3(z: ExComplex64Array3, exp: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array3_scalar(z: ExComplex64Array3, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array3(z: ExComplex64, exp: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array4_array4(z: ExComplex64Array4, exp: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array4_scalar(z: ExComplex64Array4, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array4(z: ExComplex64, exp: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array5_array5(z: ExComplex64Array5, exp: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array5_scalar(z: ExComplex64Array5, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array5(z: ExComplex64, exp: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array6_array6(z: ExComplex64Array6, exp: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_array6_scalar(z: ExComplex64Array6, exp: ExComplex64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_powc_scalar_array6(z: ExComplex64, exp: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array1_array1(z: ExComplex64Array1, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array1_scalar(z: ExComplex64Array1, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array1(z: ExComplex64, base: ExFloat64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_scalar(z: ExComplex64, base: f64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::expf(z.resource.0, base))
}

#[rustler::nif]
pub fn math_complex64_expf_array2_array2(z: ExComplex64Array2, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array2_scalar(z: ExComplex64Array2, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array2(z: ExComplex64, base: ExFloat64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array3_array3(z: ExComplex64Array3, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array3_scalar(z: ExComplex64Array3, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array3(z: ExComplex64, base: ExFloat64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array4_array4(z: ExComplex64Array4, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array4_scalar(z: ExComplex64Array4, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array4(z: ExComplex64, base: ExFloat64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array5_array5(z: ExComplex64Array5, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array5_scalar(z: ExComplex64Array5, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array5(z: ExComplex64, base: ExFloat64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array6_array6(z: ExComplex64Array6, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_array6_scalar(z: ExComplex64Array6, base: f64, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_expf_scalar_array6(z: ExComplex64, base: ExFloat64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::sin(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_sin_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sin_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sin(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::cos(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_cos_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cos_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cos(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::tan(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_tan_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tan_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tan(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::asin(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_asin_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asin_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asin(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::acos(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_acos_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acos_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acos(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::atan(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_atan_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atan_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atan(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::sinh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_sinh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_sinh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::sinh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::cosh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_cosh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_cosh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::cosh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::tanh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_tanh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_tanh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::tanh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::asinh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_asinh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_asinh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::asinh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::acosh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_acosh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_acosh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::acosh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::atanh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_atanh_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_atanh_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::atanh(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_array1(z: ExComplex64Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_scalar(z: ExComplex64) -> ExComplex64 {
    ExComplex64::new(Complex::<f64>::finv(z.resource.0))
}

#[rustler::nif]
pub fn math_complex64_finv_array2(z: ExComplex64Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_array3(z: ExComplex64Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_array4(z: ExComplex64Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_array5(z: ExComplex64Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex64_finv_array6(z: ExComplex64Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex64Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f64>::finv(z);
            });
        }
    };

    ExComplex64Array6::new(output_array)
}
