// -----------------------------------------------------
// Autogenerated file - edits to this file will be lost
// -----------------------------------------------------

use ndarray::{azip, par_azip, Array1, Array2, Array3, Array4, Array5, Array6};
use ndrustfft::Complex;
use crate::datatypes::*;

#[rustler::nif]
pub fn math_complex32_from_polar_array1_array1(r: ExFloat32Array1, theta: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array1_scalar(r: ExFloat32Array1, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array1(r: f32, theta: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_scalar(r: f32, theta: f32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::from_polar(r, theta))
}

#[rustler::nif]
pub fn math_complex32_from_polar_array2_array2(r: ExFloat32Array2, theta: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array2_scalar(r: ExFloat32Array2, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array2(r: f32, theta: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array3_array3(r: ExFloat32Array3, theta: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array3_scalar(r: ExFloat32Array3, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array3(r: f32, theta: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array4_array4(r: ExFloat32Array4, theta: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array4_scalar(r: ExFloat32Array4, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array4(r: f32, theta: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array5_array5(r: ExFloat32Array5, theta: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array5_scalar(r: ExFloat32Array5, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array5(r: f32, theta: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array6_array6(r: ExFloat32Array6, theta: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0,
                  &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0,
                       &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_array6_scalar(r: ExFloat32Array6, theta: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(r.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&r.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &r in &r.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &r in &r.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_from_polar_scalar_array6(r: f32, theta: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(theta.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&theta.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &theta in &theta.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &theta in &theta.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::from_polar(r, theta);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::exp(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_exp_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_exp_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::exp(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::ln(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_ln_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_ln_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::ln(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::sqrt(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_sqrt_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sqrt_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sqrt(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::cbrt(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_cbrt_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cbrt_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cbrt(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array1_array1(z: ExComplex32Array1, exp: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array1_scalar(z: ExComplex32Array1, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array1(z: ExComplex32, exp: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_scalar(z: ExComplex32, exp: f32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::powf(z.resource.0, exp))
}

#[rustler::nif]
pub fn math_complex32_powf_array2_array2(z: ExComplex32Array2, exp: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array2_scalar(z: ExComplex32Array2, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array2(z: ExComplex32, exp: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array3_array3(z: ExComplex32Array3, exp: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array3_scalar(z: ExComplex32Array3, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array3(z: ExComplex32, exp: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array4_array4(z: ExComplex32Array4, exp: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array4_scalar(z: ExComplex32Array4, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array4(z: ExComplex32, exp: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array5_array5(z: ExComplex32Array5, exp: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array5_scalar(z: ExComplex32Array5, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array5(z: ExComplex32, exp: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array6_array6(z: ExComplex32Array6, exp: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_array6_scalar(z: ExComplex32Array6, exp: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z, exp);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powf_scalar_array6(z: ExComplex32, exp: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powf(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array1_array1(z: ExComplex32Array1, base: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array1_scalar(z: ExComplex32Array1, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array1(z: ExComplex32, base: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_scalar(z: ExComplex32, base: f32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::log(z.resource.0, base))
}

#[rustler::nif]
pub fn math_complex32_log_array2_array2(z: ExComplex32Array2, base: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array2_scalar(z: ExComplex32Array2, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array2(z: ExComplex32, base: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array3_array3(z: ExComplex32Array3, base: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array3_scalar(z: ExComplex32Array3, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array3(z: ExComplex32, base: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array4_array4(z: ExComplex32Array4, base: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array4_scalar(z: ExComplex32Array4, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array4(z: ExComplex32, base: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array5_array5(z: ExComplex32Array5, base: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array5_scalar(z: ExComplex32Array5, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array5(z: ExComplex32, base: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array6_array6(z: ExComplex32Array6, base: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_array6_scalar(z: ExComplex32Array6, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_log_scalar_array6(z: ExComplex32, base: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::log(z.resource.0, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array1_array1(z: ExComplex32Array1, exp: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array1_scalar(z: ExComplex32Array1, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array1(z: ExComplex32, exp: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_scalar(z: ExComplex32, exp: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::powc(z.resource.0, exp.resource.0))
}

#[rustler::nif]
pub fn math_complex32_powc_array2_array2(z: ExComplex32Array2, exp: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array2_scalar(z: ExComplex32Array2, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array2(z: ExComplex32, exp: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array3_array3(z: ExComplex32Array3, exp: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array3_scalar(z: ExComplex32Array3, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array3(z: ExComplex32, exp: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array4_array4(z: ExComplex32Array4, exp: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array4_scalar(z: ExComplex32Array4, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array4(z: ExComplex32, exp: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array5_array5(z: ExComplex32Array5, exp: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array5_scalar(z: ExComplex32Array5, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array5(z: ExComplex32, exp: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array6_array6(z: ExComplex32Array6, exp: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_array6_scalar(z: ExComplex32Array6, exp: ExComplex32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z, exp.resource.0);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_powc_scalar_array6(z: ExComplex32, exp: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(exp.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&exp.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &exp in &exp.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &exp in &exp.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::powc(z.resource.0, exp);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array1_array1(z: ExComplex32Array1, base: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array1_scalar(z: ExComplex32Array1, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array1(z: ExComplex32, base: ExFloat32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_scalar(z: ExComplex32, base: f32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::expf(z.resource.0, base))
}

#[rustler::nif]
pub fn math_complex32_expf_array2_array2(z: ExComplex32Array2, base: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array2_scalar(z: ExComplex32Array2, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array2(z: ExComplex32, base: ExFloat32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array3_array3(z: ExComplex32Array3, base: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array3_scalar(z: ExComplex32Array3, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array3(z: ExComplex32, base: ExFloat32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array4_array4(z: ExComplex32Array4, base: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array4_scalar(z: ExComplex32Array4, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array4(z: ExComplex32, base: ExFloat32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array5_array5(z: ExComplex32Array5, base: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array5_scalar(z: ExComplex32Array5, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array5(z: ExComplex32, base: ExFloat32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array6_array6(z: ExComplex32Array6, base: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0,
                  &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0,
                       &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_array6_scalar(z: ExComplex32Array6, base: f32, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_expf_scalar_array6(z: ExComplex32, base: ExFloat32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(base.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&base.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &base in &base.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &base in &base.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::expf(z.resource.0, base);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::sin(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_sin_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sin_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sin(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::cos(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_cos_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cos_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cos(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::tan(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_tan_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tan_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tan(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::asin(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_asin_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asin_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asin(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::acos(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_acos_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acos_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acos(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::atan(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_atan_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atan_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atan(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::sinh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_sinh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_sinh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::sinh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::cosh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_cosh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_cosh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::cosh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::tanh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_tanh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_tanh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::tanh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::asinh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_asinh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_asinh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::asinh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::acosh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_acosh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_acosh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::acosh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::atanh(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_atanh_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_atanh_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::atanh(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_array1(z: ExComplex32Array1, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array1 {  
    let mut output_array = Array1::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array1::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_scalar(z: ExComplex32) -> ExComplex32 {
    ExComplex32::new(Complex::<f32>::finv(z.resource.0))
}

#[rustler::nif]
pub fn math_complex32_finv_array2(z: ExComplex32Array2, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array2 {  
    let mut output_array = Array2::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array2::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_array3(z: ExComplex32Array3, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array3 {  
    let mut output_array = Array3::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array3::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_array4(z: ExComplex32Array4, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array4 {  
    let mut output_array = Array4::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array4::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_array5(z: ExComplex32Array5, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array5 {  
    let mut output_array = Array5::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array5::new(output_array)
}

#[rustler::nif]
pub fn math_complex32_finv_array6(z: ExComplex32Array6, parallelization_strategy: ParallelizationStrategy) -> ExComplex32Array6 {  
    let mut output_array = Array6::zeros(z.resource.0.dim());

    match parallelization_strategy.should_be_parallel(&z.resource.0) {
        true => {
            par_azip!((output_array in &mut output_array,
                       &z in &z.resource.0) {
                // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        },

        false => {
            azip!((output_array in &mut output_array,
                   &z in &z.resource.0) {
                 // Save the result of the operation in the output array
                *output_array = Complex::<f32>::finv(z);
            });
        }
    };

    ExComplex32Array6::new(output_array)
}
